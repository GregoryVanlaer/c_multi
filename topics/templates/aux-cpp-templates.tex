\section{\cpp\ Templates}

\frame{\tableofcontents[currentsection]}

\begin{frame}
  \frametitle{\cpp\ Templates}
  \begin{itemize}
    \item In \cpp, \texttt{std::vector<T>} is not called a generic
    \item It is called a \emph{template}
    \item Templates differ fundamentally from generics
    \item Templates are much more powerful than generics
    \item Templates are also much more fragile
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{What are Templates?}
  \begin{itemize}
    \item Templates can be seen as ``code generators''
    \item Using \texttt{std::vector<int>} makes the compiler generate
          code from \texttt{std::vector<T>} with \texttt{T} replaced by \texttt{int}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Example: Array Wrapper Class}
  \code[language=c++14,font=\scriptsize,width=.99\linewidth]{array.cpp}
  \vskip-10mm
  \begin{overprint}
    \onslide<2>
    \codeunderlinex{array template}
    \begin{center}
      Indicates the class is a template
    \end{center}
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{Templates Generated By Need}
  \begin{itemize}
    \item Exact generation rules are rather complex
    \item Only the member functions you actually use are generated
    \item Function bodies not checked if you don't call them
  \end{itemize}
  \begin{overprint}
    \onslide<1>
    \code[language=c++14,font=\scriptsize,width=.8\linewidth]{by-need.cpp}
    \onslide<2>
    \code[language=c++14,font=\scriptsize,width=.8\linewidth]{by-need2.cpp}
    \onslide<3>
    \code[language=c++14,font=\scriptsize,width=.8\linewidth]{by-need3.cpp}
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{Consequences of By Need Generation}
  \begin{itemize}
    \item By need generation gives extra flexibility
    \item Allows you to define functions that only work for certain \texttt{T}s
  \end{itemize}
  \code[language=c++14,font=\scriptsize,width=.65\linewidth]{array-sum.cpp}
\end{frame}

\begin{frame}
  \frametitle{\texttt{Array<T>::sum} on \texttt{int}}
  \code[language=c++14,font=\scriptsize,width=.65\linewidth]{array-sum-int.cpp}
  \vskip-8mm
  \begin{overprint}
    \onslide<1>
    \codeunderlinex{array int xs}
    \begin{center}
      \texttt{int*} is perfectly valid type
    \end{center}

    \onslide<2>
    \codeunderlinex{array int return type}
    \begin{center}
      \texttt{int} as return type is ok
    \end{center}

    \onslide<3>
    \codeunderlinex{array int init}
    \begin{center}
      We can initialize an \texttt{int} with \texttt{0}
    \end{center}

    \onslide<4>
    \codeunderlinex{array int add}
    \begin{center}
      \texttt{int + int} is valid
    \end{center}
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{\texttt{Array<T>::sum} on \texttt{double}}
  \code[language=c++14,font=\scriptsize,width=.65\linewidth]{array-sum-double.cpp}
  \vskip-8mm
  \begin{overprint}
    \onslide<1>
    \codeunderlinex{array double xs}
    \codeunderlinex{array double return type}
    \codeunderlinex{array double init}
    \codeunderlinex{array double add}
    \begin{center}
      Everything is ok
    \end{center}
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{\texttt{Array<T>::sum} on \texttt{std::string}}
  \code[language=c++14,font=\scriptsize,width=.65\linewidth]{array-sum-string.cpp}
  \vskip-5mm
  \begin{overprint}
    \onslide<1>
    \codeunderlinex{array std::string xs}
    \begin{center}
      \texttt{std::string*} is valid
    \end{center}

    \onslide<2>
    \codeunderlinex{array std::string return type}
    \begin{center}
      \texttt{std::string} as return type is ok
    \end{center}

    \onslide<3>
    \codeunderlinex{array std::string add}
    \begin{center}
      \texttt{string + string} is defined, corresponds to concatenation
    \end{center}

    \onslide<4>
    \codeunderlinex{array std::string init}
    \begin{center}
      Can we initialize a string with \texttt{0}?
    \end{center}
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{\texttt{Array<T>::sum} on \texttt{std::string}}
  \begin{center} \ttfamily
    std::string result = 0;
  \end{center}
  \begin{itemize}
    \item Is this valid?
    \item If it is indeed valid, we want it to be equivalent with
          \begin{center} \ttfamily
            std::string result = "";
          \end{center}
    \item We don't want it to compile if it does something different
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{\texttt{Array<T>::sum} on \texttt{std::string}}
  \begin{center} \ttfamily
    std::string result = 0;
  \end{center}
  \begin{itemize}
    \item Initialising a string to \texttt{0} is indeed valid \cpp
    \item But sadly, it does not to what you want it to do
          \begin{itemize}
            \item It calls the constructor taking a \texttt{const char*}
            \item It initiaises the string with characters located at memory address \texttt{0}
            \item This of course leads to undefined behaviour
          \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Solving the \texttt{sum} Problem}
  \begin{itemize}
    \item We need to associate a ``zero element'' with each type
          \begin{center}
            \begin{tabular}{cc}
              \textbf{Type} & \textbf{Zero value} \\
              \toprule
              \texttt{int} & 0 \\
              \texttt{double} & 0.0 \\
              \texttt{std::string} & "" \\
              \vdots & \vdots \\
              \bottomrule
            \end{tabular}
          \end{center}
  \end{itemize}
  \code[language=c++14,font=\scriptsize,width=.65\linewidth]{array-sum-zero.cpp}
  \codeunderlinex{array sum zero}
\end{frame}

\begin{frame}
  \frametitle{Template Specialisation}
  \begin{itemize}
    \item It is possible to give different definitions for different types
  \end{itemize}
  \vskip5mm
  \begin{overprint}
    \onslide<1>
    \code[language=c++14,font=\small,width=.65\linewidth]{typeinfo-t.cpp}

    \onslide<2>
    \code[language=c++14,font=\small,width=.65\linewidth]{typeinfo-int.cpp}

    \onslide<3>
    \code[language=c++14,font=\small,width=.65\linewidth]{typeinfo-double.cpp}

    \onslide<4>
    \code[language=c++14,font=\small,width=.65\linewidth]{typeinfo-string.cpp}
  \end{overprint}
\end{frame}

\begin{frame}
  \frametitle{Template Functions}
  \begin{itemize}
    \item You can also define template functions
  \end{itemize}
  \code[language=c++14,font=\small,width=.75\linewidth]{template-function.cpp}
\end{frame}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "templates"
%%% End:
